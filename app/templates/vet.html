{% extends "base.html" %}

{% block scripts %}
    <!-- Sourcing libraries and scripts -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="{{url_for('static', filename='leaflet/leaflet.js')}}"></script>
    <!-- <script src="{{url_for('static', filename='vetting_maps.js')}}"></script> -->
    <link rel="stylesheet" href="{{url_for('static', filename='leaflet/leaflet.css')}}">
    <link rel="stylesheet" href="{{url_for('static', filename='vetting.css')}}">

    <!-- JSON object containing the geocoded data and trigger is stored here -->
    <meta id='gc_json' 
        data-trigger="{{ show_map }}"
        data-json='{{ vet_json|tojson|safe }}'
    >

    <script>
        // *** FUNCTION DEFINITIONS ***
        // Make a Leaflet map, with no layers and an OSM background
        function makeMap(map_id){
            var TILE_URL = "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png";
            var MB_ATTR = 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors';
            var mymap = L.map(map_id).setView([0, 0], 1);
            L.tileLayer(TILE_URL, {attribution: MB_ATTR}).addTo(mymap);
            return mymap
        }

        // Add all keys from a Javascript object to an array (list)
        function getKeysFromObject(obj){
            var keys = [];
            for(var k in obj) keys.push(k);
            return(keys)
        }

        // Given the ID of a `<select>` object in the page and an array of 
        //  values, fill the select object with the values.
        function fillDropDownMenu(id, arr){
            $(id).empty();
            $(id).append($('<option disabled selected value> -- select an option -- </option>'));
            $.each(arr, function(i, p){
                $(id).append($('<option></option>').val(p).html(p));
            });
            // Enable the drop-down menu
            $(id).removeAttr('disabled');            
        }

        // Helper function to return only unique items from an array
        function onlyUnique(value, index, self) { 
           return self.indexOf(value) === index;
        }

        // Given a vetting object from the geocoding tool, create a list of 
        //  valid point+buffer results
        function parseResultsFromObject(obj){
            // Get the array of all object keys
            var keys = getKeysFromObject(obj);
            // Get the list of all geocoding results, which should all contain
            //  an underscore (but not two in a row)
            var gc_results = keys.filter(k => k.includes("_") && !(k.includes("__")));
            // Split into source types and suffixes
            var prefixes = gc_results.map(function(r){ return r.split("_")[0] }).filter( onlyUnique );
            var suffixes = gc_results.map(function(r){ return r.split("_")[1] }).filter( onlyUnique );
            // Attempt to create a new valid result for each prefix (source)
            var valid_results = {};
            for(var i = 0; i < prefixes.length; i++){
                var pf = prefixes[i];
                // If the object has non-null 'lat' and 'long' fields, it is valid
                if( (pf.concat("_lat") in obj) && 
                    (obj[pf.concat("_lat")] != null) &&
                    (pf.concat("_long") in obj) && 
                    (obj[pf.concat("_long")] != null) 
                    ){
                    // Create a new sub-object with all non-null values
                    var sub_object = {};
                    for(var j = 0; j < suffixes.length; j++){
                        var sf = suffixes[j];
                        var full_field = [pf, sf].join("_");
                        if( obj[full_field]!=null ){
                            sub_object[sf] = obj[full_field];
                        } else {
                            if(sf=='buffer') sub_object['buffer'] = 0;
                        };
                    };
                    // Add the new sub-object to the list of all valid results
                    valid_results[pf] = sub_object;
                };
            };
            return valid_results
        }

        // Given a set of valid objects, create leaflet markers and add them to
        // the map
        function addResultMarkers(gc_results, mymap, layer){
            // Iterate through all results and create markers for each
            var result_keys = getKeysFromObject(gc_results);
            var markers = [];
            // Create markers for all locations and circles for locations
            //  with a buffer greater than 0
            for(i=0; i < result_keys.length; i++){
                var key = result_keys[i];
                var marker = L.marker(
                    L.latLng(
                        {lat: gc_results[key]['lat'], lng: gc_results[key]['long']}
                    ),
                    { opacity:0.5 }
                );
                marker.bindTooltip(
                    key, 
                    {permanent:true, className:"tooltip", offset:[0, 0], opacity:0.75}
                );
                markers.push(marker);
                // If the buffer is greater than 0, make a circle
                if((gc_results[key]['buffer'] != null) && (gc_results[key]['buffer'] > 0)){
                    var circle = L.circle(
                        L.latLng(
                            {lat: gc_results[key]['lat'], lng: gc_results[key]['long']}
                        ),
                        { 
                            opacity: 0.4,
                            color: 'blue',
                            fillColor: 'blue',
                            fillOpacity: 0.15,
                            radius: gc_results[key]['buffer'] * 1000
                        }
                    );
                    markers.push(circle);
                };
            };
            // Add new markers
            mymap.removeLayer(layer);
            layer = L.layerGroup(markers);
            mymap.addLayer(layer);
            // Zoom to markers
            var group = new L.featureGroup(markers)
            mymap.fitBounds(group.getBounds(), {padding : L.point(20,20)});
        }

        // Given a set of valid objects, populate a div with information about 
        //   all valid objects
        function addResultDetails(address, iso, gc_formatted, div_id){
            // Add overall data about the address and ISO (if available)
            $(div_id).append($('<h2></h2>').html(address));
            if(iso != null){
                 $(div_id).append($('<h3></h3>').html('Country: ' + iso));
            };
            // If there are no results, say so; otherwise, add each result
            if( Object.keys(gc_formatted).length == 0){
                $(div_id).append($('<p></p>').html('<i>No valid results returned.</i>'));
            } else {
                var valid_keys = getKeysFromObject(gc_formatted);
                for(i = 0; i < valid_keys.length; i++){
                    vk = valid_keys[i];
                    $(div_id).append($('<h3></h3>').html(vk));
                    var subkeys = getKeysFromObject(gc_formatted[vk]);
                    for (j = 0; j < subkeys.length; j++){
                        var sk = subkeys[j];
                        $(div_id).append('<b>'+sk+'</b>: '+gc_formatted[vk][sk]+'<br>');
                    };
                };
            };
        }

        // *** LEAFLET SCRIPT EXECUTION BEGINS HERE ***
        var show_map = $('#gc_json').data("trigger");

        $(function() {
            if( show_map == 1 ){
                // Create a map and add a blank layer object
                var mymap = makeMap('leafmap');
                var layer = L.layerGroup();
                mymap.addLayer(layer);
                // Parsing an 'over-stringified' string to JSON
                // This seems to be the only safe way to retrieve JSON from a 
                //  <meta> object
                var gc_json = JSON.parse(JSON.parse( $('#gc_json').data("json") )); 
                // Add keys of the object to the drop-down selection
                var gc_keys = getKeysFromObject(gc_json);
                fillDropDownMenu('#gc_result', gc_keys);
                // When a value is selected, use it to create a map
                $('#gc_result').change(function(){
                    // Get the selection and use it to populate a list of results
                    var gc_selection = $('#gc_result option:selected').val();
                    var gc_results = parseResultsFromObject(gc_json[gc_selection]);
                    // Use these results to populate points on a map
                    addResultMarkers(gc_results, mymap, layer);
                    addResultDetails(
                        gc_selection, gc_json[gc_selection]['iso2'], gc_results, 
                        '#disp_results'
                    );
                });
            }
        })
    </script>
{% endblock %}


{% block content %}
    <form action="{{url_for('vet') }}" method="post" novalidate>
        {{ form.hidden_tag() }}
        <!-- Iterate through all form fields -->
        {% for field in form %}
            {% if field.type not in ["SubmitField","CSRFTokenField"] %}
                <p>
                    {{ field.label }} <br>
                    {{ field(size=32) }} <br>
                    {% for error in field.errors %}
                        <span style="color: red;">[{{ error }}]</span>
                    {% endfor %}
                </p>
            {% endif %} 
        {% endfor %}
        <p>
            {{ form.submit() }}
        </p>
    </form>
    <!-- Selection menu will show up here -->
    <select disabled id='gc_result'></select>
    <!-- Leaflet map will display here -->
    <div id='leafmap'></div>
    <hr>
    <div id='disp_results'></div>
{% endblock %}